<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <style>
        #box{
           width: 500px;
           height: 500px;
           background: red;
           z-index:2;
           position: absolute;
        }
        div#scaleBox{
            display: inline-block;
            position:absolute;
            z-index:1;
        }
    </style>
</head>
<body>

      <div id="box"></div>

<script>
    var sb = document.getElementById('box');
    var touchStartX = 0;
    var touchStartY = 0;
    var touchLeft = 0;
    var touchTop = 0;
    var scaleBox;  // 后面生成的拖动元素
    var hasCreate = false;  // 只允许元素生成一次

    var targetSpacing;   //  新生成的拖动元素的 间距(与内元素的间距)  和  宽高
    var targetWidth;
    var targetHeight;

    var currentEle = sb; // 默认为sb
    var isPc = isPc();  //  移动端和PC端判断

    var eventType = {
        down : (isPc?"mousedown":"touchstart"),  // 多次重复判断 是否有修改的余地？
        move : (isPc?"mousemove":"touchmove"),
        end : (isPc?"mouseup":"touchend")
    }
    function startDown(e){
        currentEle = this;
        touchStartX = (isPc?e.clientX:e.touches[0].clientX);
        touchStartY = (isPc?e.clientY:e.touches[0].clientY);
        touchLeft = currentEle.offsetLeft;
        touchTop = currentEle.offsetTop;
        currentEle.addEventListener(eventType.move,startMove);
        currentEle.addEventListener(eventType.end,startEnd);
    }

    function startMove(e){
         deleteScale(); //  移动时清除缩放元素
         var moveX = (isPc?e.clientX:e.touches[0].clientX);
         var moveY = (isPc?e.clientY:e.touches[0].clientY);
         //  我喜欢变形本 ， 这玩意不仅携带方便 而且打字也是超舒服，不知道surface的键盘如何
        // 思路堵了啦  草，  e.touches[0].clientX 与 e.clientX 如何共存呢，还真是个严肃的问题呀?
        currentEle.style.left = touchLeft + (moveX-touchStartX) + 'px';
        currentEle.style.top = touchTop + (moveY-touchStartY) + 'px';  // 不减去touchStartY的话 会在元素顶部拖拽
    }
    function startEnd(){
       if(isPc){
          document.removeEventListener(eventType.down,startDown);  // 解绑
          currentEle.removeEventListener(eventType.move,startMove);
          console.log('click is end');
          return;
       }
       console.log('touch is end');
    }


   //  事件绑定
    currentEle.addEventListener(eventType.down,startDown);
    document.addEventListener(eventType.down,deleteScale);

     document.addEventListener('keydown',function(e){
         if(e.ctrlKey && e.keyCode == 81){
            if(startScale(currentEle)){  // 如果拖拽元素成功创建的话，则绑定拖动事件
                scaleBox.addEventListener(eventType.move,function(e){
//                 console.log(e.touches[0].clientX + 'widht: ' + this.offsetWidth)

                     var scaleX = e.touches[0].clientX - this.offsetWidth - this.offsetLeft;
                     var scaleY = e.touches[0].clientY - this.offsetHeight - this.offsetTop;
                     if(!checkSize(currentEle)){
                         this.style.width = this.offsetWidth + 'px';
                         this.style.height = this.offsetHeight  + 'px';
                     }
                    this.style.width = this.offsetWidth + scaleX + 'px';
                    this.style.height = this.offsetHeight + scaleY + 'px';

                    sb.style.width = sb.offsetWidth + (this.offsetWidth - sb.offsetWidth) - targetSpacing + 'px'; //要减掉多余的targetSpacing间距
                    sb.style.height = sb.offsetHeight + (this.offsetHeight - sb.offsetHeight) - targetSpacing + 'px';

                    return false;
             })

                 scaleBox.addEventListener('touchend',function(){

                        // 缩放结束时 检测 最大/最小值
                 })

           }  //  startScale(sb);
         }  // end if keydown
     })

   function checkSize(ele){
       var min = 50;
       var max = document.body.clientWidth;
          //  怎么计算触碰到 屏幕边缘呢 ？
       document.title = ele.offsetWidth;
       if(ele.offsetWidth <= min || ele.offsetWidth >= max){
           return false;
       }
       if(ele.offsetHeight <= min || ele.offsetHeight>= max){
           return false;
       }
       return true;
   }

   function startScale(ele){
       targetSpacing = 90;
       targetWidth = ele.offsetWidth + targetSpacing;
       targetHeight = ele.offsetHeight + targetSpacing;

       try {
           if (!hasCreate) {
               var newScale = document.createElement('div');
               newScale.style.position = 'absolute';
               newScale.style.width = targetWidth + 'px';
               newScale.style.height = targetHeight + 'px';
               newScale.style.left = ele.offsetLeft - ((targetWidth - ele.offsetWidth) / 2) + 'px';
               newScale.style.top = ele.offsetTop - ((targetHeight - ele.offsetHeight) / 2) + 'px';
               newScale.style.border = '5px dashed #000';
//               newScale.style.backgroundColor = '#000';
               newScale.setAttribute('id', 'scaleBox');
               document.body.appendChild(newScale);
               hasCreate = true;
           }
           scaleBox = document.getElementById('scaleBox');
       }catch(e){
           console.log(e);
           return false;
       }
       return true;
   }
    function deleteScale(){
        if(hasCreate){
            document.body.removeChild(scaleBox);
            hasCreate = false;
        }
    }
    function isPc(){
        if('ontouchstart' in document){
            return false;
        }
        return true;
    }
</script>
</body>
</html>