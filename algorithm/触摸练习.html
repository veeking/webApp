<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <style>
        #box{
           width: 500px;
           height: 500px;
           background: red;
           z-index:2;
           position: absolute;
        }
        div#scaleBox{
            display: inline-block;
            position:absolute;
            z-index:1;
        }
    </style>
</head>
<body>

      <div id="box"></div>

<script>
    // 目前三大问题：
    //  1、点击空白地方去除缩放元素，如果是document的话，是点击所有的地方都触发，而不是空白地方
    //  2、触摸缩放可以直接拖拽移动，但是鼠标就必须先要按下才行? (目前想到的方法：还是加一层按下事件吧 )
    //  3、多元素继承(currentEle默认为每一次新生成的元素，每一次生成元素后都要遍历绑定事件，点击元素后更换currentEle)
    var sb = document.getElementById('box');
    var touchStartX = 0;
    var touchStartY = 0;
    var touchLeft = 0;
    var touchTop = 0;
    var scaleBox;  // 后面生成的拖动元素
    var hasCreate = false;  // 只允许元素生成一次

    var targetSpacing;   //  新生成的拖动元素的 间距(与内元素的间距)  和  宽高
    var targetWidth;
    var targetHeight;

    var currentEle = sb; // 默认为sb
    var isPc = isPc();  //  移动端和PC端判断

    var eventType = {
        down : (isPc?"mousedown":"touchstart"),  // 多次重复判断 是否有修改的余地？
        move : (isPc?"mousemove":"touchmove"),
        end : (isPc?"mouseup":"touchend")
    }
    function startDown(e){
        currentEle = this;
        touchStartX = (isPc?e.clientX:e.touches[0].clientX);
        touchStartY = (isPc?e.clientY:e.touches[0].clientY);
        touchLeft = currentEle.offsetLeft;
        touchTop = currentEle.offsetTop;
        currentEle.addEventListener(eventType.move,startMove);
        currentEle.addEventListener(eventType.end,startEnd);
        e.stopPropagation();
    }

    function startMove(e){
         deleteScale(); //  移动时清除缩放元素
         var moveX = (isPc?e.clientX:e.touches[0].clientX);
         var moveY = (isPc?e.clientY:e.touches[0].clientY);
         //  我喜欢变形本 ， 这玩意不仅携带方便 而且打字也是超舒服，不知道surface的键盘如何
        // 思路堵了啦  草，  e.touches[0].clientX 与 e.clientX 如何共存呢，还真是个严肃的问题呀?
        currentEle.style.left = touchLeft + (moveX-touchStartX) + 'px';
        currentEle.style.top = touchTop + (moveY-touchStartY) + 'px';  // 不减去touchStartY的话 会在元素顶部拖拽
    }
    function startEnd(){
       if(isPc){
          document.removeEventListener(eventType.down,startDown);  // 解绑
          currentEle.removeEventListener(eventType.move,startMove);
          console.log('click is end');
          return;
       }
       console.log('touch is end');
    }
   function startScale(e){
       var moveX = (isPc?e.clientX:e.touches[0].clientX);
       var moveY = (isPc?e.clientY:e.touches[0].clientY);
       var scaleX = moveX - this.offsetWidth - this.offsetLeft;
       var scaleY = moveY - this.offsetHeight - this.offsetTop;
       if(!checkSize(currentEle)){
           this.style.width = this.offsetWidth + 'px';
           this.style.height = this.offsetHeight  + 'px';
       }
       this.style.width = this.offsetWidth + scaleX + 'px';
       this.style.height = this.offsetHeight + scaleY + 'px';

       currentEle.style.width = currentEle.offsetWidth + (this.offsetWidth - currentEle.offsetWidth) - targetSpacing + 'px'; //要减掉多余的targetSpacing间距
       currentEle.style.height = currentEle.offsetHeight + (this.offsetHeight - currentEle.offsetHeight) - targetSpacing + 'px';

       return false;
   } // end startScale


   //  事件绑定
    currentEle.addEventListener(eventType.down,startDown);
    document.addEventListener(eventType.down,deleteScale);

    // 启动拖拽
     document.addEventListener('keydown',function(e){
         if(e.ctrlKey && e.keyCode == 81){
            if(createScale(currentEle)){  // 如果拖拽元素成功创建的话，则绑定拖动事件
               scaleBox.addEventListener(eventType.down,function(e){  // 按下启动拖拽
                   scaleBox.addEventListener(eventType.move,startScale);
                   scaleBox.addEventListener(eventType.end,function(){
                       this.removeEventListener(eventType.move,startScale);
                       console.log('缩放结束，你可以做点什么...');
                       // 缩放结束时 检测 最大/最小值
                   });
                   e.stopPropagation();
               });// end scaleBox down

           }  //  createScale(sb);
         }  // end if keydown
     })

   function checkSize(ele){
       var min = 50;
       var max = document.body.clientWidth;
          //  怎么计算触碰到 屏幕边缘呢 ？
       document.title = ele.offsetWidth;
       if(ele.offsetWidth <= min || ele.offsetWidth >= max){
           return false;
       }
       if(ele.offsetHeight <= min || ele.offsetHeight>= max){
           return false;
       }
       return true;
   }

   function createScale(ele){
       targetSpacing = 90;
       targetWidth = ele.offsetWidth + targetSpacing;
       targetHeight = ele.offsetHeight + targetSpacing;

       try {
           if (!hasCreate) {
               var newScale = document.createElement('div');
               newScale.style.position = 'absolute';
               newScale.style.width = targetWidth + 'px';
               newScale.style.height = targetHeight + 'px';
               newScale.style.left = ele.offsetLeft - ((targetWidth - ele.offsetWidth) / 2) + 'px';
               newScale.style.top = ele.offsetTop - ((targetHeight - ele.offsetHeight) / 2) + 'px';
               newScale.style.border = '5px dashed #000';
//               newScale.style.backgroundColor = '#000';
               newScale.setAttribute('id', 'scaleBox');
               document.body.appendChild(newScale);
               hasCreate = true;
           }
           scaleBox = document.getElementById('scaleBox');
       }catch(e){
           console.log(e);
           return false;
       }
       return true;
   }
    function deleteScale(){
        if(hasCreate){
            document.body.removeChild(scaleBox);
            hasCreate = false;
        }
    }
    function isPc(){
        if('ontouchstart' in document){
            return false;
        }
        return true;
    }
</script>
</body>
</html>