<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no, width=device-width">
    <title></title>
    <style>
        *{
            margin:0;
            padding: 0;
        }
        body,html{
            width:100%;
            height:100%;
        }
        body{
           background: #4d4d4d;
        }
        div#view{
            width:98%;
            height:82%;
            margin:0 auto;
            outline: 2px solid #00B7FF;
        }
        div#viewShow{
           width：100%;
           height:100%;
           position:relative;
        }
        div#viewShow div.newEle{
            position: absolute;
        }
        button{
            border: none;
            cursor: pointer;
            font-family: '微软雅黑';
        }
        button#viewButton{
              width:100%;
              height:20%;
              background: #00B7FF;
              color: #fff;
              font-size: 16pt;
              vertical-align: middle;
              transition:transform 0.3s linear;
          }

        button#viewButton:active{
            transform:translateY(10px);
            background:#285e8e;
        }
        div#scaleBox{
            display: inline-block;
            position:absolute;
            z-index:1;
        } div#sb{
            width:300px;
            height: 300px;
            background: #006600;
            position:absolute;
            z-index:1;
        }
    </style>
</head>
<body>
    <div id="view">
        <div id="viewShow">
            <div id="sb">

            </div>
        </div>
        <button id="viewButton">Create New</button>
    </div>

<script src="/socket.io/socket.io.js"></script>
<script>
   var socket = io.connect('http://127.0.0.1:3000/');
   socket.emit('newClient');
   socket.on('newNode',function(e){
       alert(e);
   });
   //  面向对象化重构 : 封装起来
  // socketIo 和 动画
  //  目前问题：手机端 缩放严重卡顿，拖拽好好的 为什么缩放就卡顿?
  function DragApp(opt){  // 无需外部调用任何方法 ， 传参数后即可内部完成所有功能
     if(typeof opt != Object && opt == null){
        return false;
     }
      // 公共属性 外部可获取
      var showView  = opt.showBox;
      var createBtn = opt.showBtn;
      var sb = document.getElementById('sb');
      var touchStartX = 0;
      var touchStartY = 0;
      var touchLeft = 0;
      var touchTop = 0;
      var scaleBox;  //  生成的拖动元素
      var hasCreate = false;  // 只允许元素生成一次

      var targetSpacing = 30;   //  拖动元素的 间距(与内元素的间距)  和  宽高

      var currentEle = sb; // 默认为空
      var eleBox = []; // 存放所有生成的元素
      var eleLayoutIndex = 1;


      var longTime = null;
      var scaleOn = true;

      var isPc = isPc();
      var eventType = {
          down : (isPc?"mousedown":"touchstart"),  // 多次重复判断 是否有修改的余地？
          move : (isPc?"mousemove":"touchmove"),
          end : (isPc?"mouseup":"touchend")
      };

      createBtn.addEventListener(eventType.down,createEle);
      currentEle.addEventListener(eventType.down,startDown);
      function createEle(e){  // 位置 大小  颜色

          var size = showView.offsetWidth / 4; // 宽高为 1/4
          var coord = getCoord(size)// 随机位置 coord.x and coord.y
          var color = ['red','green','blue'];  //三种随机颜色 color[Math.random()*color.length]
          var className = 'newEle';
          var i;
          var longTimeCount = 0; // 长按计时器
          // 创建
          try {
              var newEle = document.createElement('div');
              newEle.style.width = size + 'px';
              newEle.style.height = size + 'px';
              newEle.style.left = coord.x + 'px';
              newEle.style.top = coord.y + 'px';
              newEle.style.background = color[Math.floor(Math.random() * color.length)];
              newEle.setAttribute('class', className);
              eleBox[eleBox.length] = newEle;  // 把新元素推进数组，方便后续操作
              showView.appendChild(newEle);
          }catch(e){
              alert('创建元素时出现了个错误' + e);
          }; // end try
            console.log(eleBox)
          deleteScale();  // 创建新元素时， 删除拖拽 并让current为最新生成的元素
          currentEle = eleBox[eleBox.length - 1];

          for(i = 0;i < eleBox.length;i++){
              eleBox[i].addEventListener(eventType.down,startDown);
          } // end for

          document.addEventListener(eventType.down,deleteScale);

          currentEle.addEventListener(eventType.down,function(){
               if(scaleOn){
                  deleteScale();  // 每次点击切换时，先删除旧的，再在新的当前元素生成新的
                  longTimeCount = 0; //  点击时 恢复  默认
                  longTime = setInterval(function(){  //  应该是没有移动的情况下点击
                      console.log('setInterval运行了');
                      longTimeCount++;
                      if(longTimeCount >= 10){
                          createScale(currentEle);
                          clearInterval(longTime);
                          if(hasCreate){  // 元素生成后才可以拖拽、删除
                              scaleBox.addEventListener(eventType.down,function(e){  // 按下启动拖拽
                                  document.addEventListener(eventType.move,startScale);
                                  document.addEventListener(eventType.end,function(){
                                      document.removeEventListener(eventType.move,startScale);
                                      console.log('缩放结束，你可以做点什么...');
                                      // 缩放结束时 要做的事 -> [检测 最大/最小值]
                                  });
                                  e.stopPropagation(); // 取消冒泡  防止与document的点击事件冲突ss
                              });// end scaleBox down

                          }  //  createScale(sb);
                      }
                  },60);

              }
              currentEle.addEventListener(eventType.end,function(){
                  clearInterval(longTime);
              })
          });  // end currentEle down
          e.stopPropagation();
      }; // end function createEle()

      function startDown(e){
          scaleOn = true;
          currentEle = this;
          currentEle.style.zIndex = ++eleLayoutIndex;
          touchStartX = (isPc?e.clientX:e.touches[0].clientX);
          touchStartY = (isPc?e.clientY:e.touches[0].clientY);
          touchLeft = currentEle.offsetLeft;
          touchTop = currentEle.offsetTop;
          document.addEventListener(eventType.move,startMove);
          document.addEventListener(eventType.end,startEnd);
          e.stopPropagation();
          e.preventDefault();
      }

      function startMove(e){
          if(hasCreate){
              deleteScale(); //  移动时清除缩放元素
          }
          clearInterval(longTime);
          var moveX = (isPc?e.clientX:e.touches[0].clientX);
          var moveY = (isPc?e.clientY:e.touches[0].clientY);
          var mx = touchLeft + (moveX-touchStartX);
          var my = touchTop + (moveY-touchStartY);
          // 边缘检测
          if(mx < targetSpacing){
             mx = targetSpacing;
          }else if(mx > showView.offsetWidth - currentEle.offsetWidth){
             mx = showView.offsetWidth - currentEle.offsetWidth;
          }
          if(my < targetSpacing){
              my = targetSpacing;
          }else if(my > showView.offsetHeight - currentEle.offsetHeight){
              my = showView.offsetHeight - currentEle.offsetHeight;
          }
      // 不减去touchStartY的话 会在
          socket.emit('clientData',{mx:mx,my:my}); //  服务端交互 :很卡顿
          socket.on('nodeData',function(e){
              mx = e.x;
              my = e.y;
          });
          currentEle.style.left = mx + 'px';
          currentEle.style.top = my + 'px';
          //元素顶部拖拽
      }

       function startEnd(){
          scaleOn = true;
          document.removeEventListener(eventType.down,startDown);  // 解绑
          document.removeEventListener(eventType.move,startMove);
          console.log('event is end');
      }
      function startScale(e){  // offsetLeft是showView里计算的，正常情况下是从document下计算的
          var moveX = (isPc?e.clientX:e.touches[0].clientX);
          var moveY = (isPc?e.clientY:e.touches[0].clientY);
          var scaleX = moveX - scaleBox.offsetWidth - (scaleBox.offsetLeft + showView.offsetLeft);
          var scaleY = moveY - scaleBox.offsetHeight - (scaleBox.offsetTop + showView.offsetTop);
          var w = scaleBox.offsetWidth + scaleX;
          var h = scaleBox.offsetHeight + scaleY;
          //缩放 边缘检测
          if(w < targetSpacing){
              w = targetSpacing + 10;
          }else if(w > showView.offsetWidth - scaleBox.offsetLeft){
              w = showView.offsetWidth - scaleBox.offsetLeft - 10;
          };
          if(h < targetSpacing){
              h = targetSpacing + 10;
          }else if(h > showView.offsetHeight - scaleBox.offsetTop){
              h = showView.offsetHeight - scaleBox.offsetTop - 10;
          };

          scaleBox.style.width = w + 'px';
          scaleBox.style.height = h + 'px';

          currentEle.style.width = currentEle.offsetWidth + (scaleBox.offsetWidth - currentEle.offsetWidth) - targetSpacing - 10 + 'px'; //要减掉多余的targetSpacing间距
          currentEle.style.height = currentEle.offsetHeight + (scaleBox.offsetHeight - currentEle.offsetHeight) - targetSpacing - 10 + 'px'; // 10PX为拖拽元素的边框 要减掉

          return false;
      } // end startScale

      function createScale(ele){
          var targetWidth = ele.offsetWidth + targetSpacing;
          var targetHeight = ele.offsetHeight + targetSpacing;

          try {
              if (!hasCreate) {
                  var newScale = document.createElement('div');
                  newScale.style.width = targetWidth + 'px';
                  newScale.style.height = targetHeight + 'px';
                  newScale.style.left = ele.offsetLeft - ((targetWidth - ele.offsetWidth) / 2) - 5 + 'px';
                  newScale.style.top = ele.offsetTop - ((targetHeight - ele.offsetHeight) / 2) - 5 + 'px';
                  newScale.style.zIndex = eleLayoutIndex - 1; // 低于元素层
                  newScale.style.border = '5px dashed #000';
//             newScale.style.backgroundColor = '#000';
                  newScale.setAttribute('id', 'scaleBox');
                  showView.appendChild(newScale);
                  hasCreate = true;
              }
              scaleBox = document.getElementById('scaleBox');
          }catch(e){
              console.log(e);
              return false;
          }
          return true;
      }
      function deleteScale(){
          scaleOn = false;  // 关闭拖动
          if(hasCreate){
              showView.removeChild(scaleBox);
              hasCreate = false;
          }
      };
      function isPc(){
          if('ontouchstart' in document){
              return false;
          }
          return true;
      }
      function getCoord(eleSize){
          var coordObj = {};
          var maxX = showView.offsetWidth - eleSize - (targetSpacing*2); // 最大值=显示总宽度 - 元素宽度 - 拖拽元素的间距
          var maxY = showView.offsetHeight - eleSize - (targetSpacing*2);
          coordObj.x = Math.floor(Math.random() * maxX + targetSpacing); // 最小值=从间距开始而不是0
          coordObj.y = Math.floor(Math.random() * maxY + targetSpacing);
          return coordObj;
      }

  };  // end DragApp


   // 启动功能
     new DragApp({
         showBox : document.getElementById('viewShow'),
         showBtn : document.getElementById('viewButton')
     });
</script>
</body>
</html>